#LyX 1.6.4 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{tikz}
\end_preamble
\use_default_options true
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Golisp
\end_layout

\begin_layout Standard
Golisp is a dialect of Lisp written in Go
\begin_inset Foot
status open

\begin_layout Plain Layout
http://www.golang.org/
\end_layout

\end_inset

.
 It has features in common with Scheme
\begin_inset Foot
status open

\begin_layout Plain Layout
http://www.schemers.org/
\end_layout

\end_inset

 and Common Lisp, but is much smaller than both.
 If you squint hard enough, it's almost compliant with Scheme standards,
 but it doesn't have continuations.
 A very simple evaluation mechanism is used, based on the metacircular evaluator.
 Annotations are added by a compilation step within the evaluator to improve
 performance (mostly to make variable lookup fast).
\end_layout

\begin_layout Standard
Go seems like a good language for implementing interpreters for other languages
 in.
 It has enough expressiveness to easily define the basics of a Lisp system.
 In particular, the garbage collector, the mechanism for dynamic types and
 built-in maps greatly eased development.
 The work presented here is based on two previous interpreters.
 The first was a straight metacircular interpreter, the second an evaluator
 for a version of Scheme that had been transformed into continuation-passing
 style.
 The first suffered from being intolerably slow, the second from difficulty
 in debugging.
 The Golisp interpreter tries to chart a course between these two approaches,
 so as to reap the performance benefits of the latter without sacrificing
 the introspective capacity of the former.
 Variable lookup, in all cases, is fast: it is either a slice index or a
 field lookup, perhaps followed by a function call that does another field
 lookup.
 This is far in preference to a metacircular evaluator, where a tree would
 have to be parsed.
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Section
Base Language
\end_layout

\begin_layout Standard
The core of Golisp is based heavily on Scheme.
 The surface syntax is based on 
\emph on
s-expressions
\emph default
.
 There are five 
\emph on
standard forms
\emph default
, that everything in the language can be reduced to.
 This reduction step is performed by 
\emph on
macros
\emph default
, that are defined in terms of 
\emph on
functions
\emph default
.
 After that, two further processing steps are applied.
 One expands 
\emph on
lambda expressions
\emph default
 with extra information, to facilitate later stages of 
\emph on
evaluation
\emph default
.
 The other transforms all references to 
\emph on
variables
\emph default
 into precise instructions on how to find them at run-time as well as handling
 other issues regarding variable management.
\end_layout

\begin_layout Standard
All of the emphasised terms will be discussed below.
\end_layout

\begin_layout Subsection
Differences From...
\end_layout

\begin_layout Standard
Scheme
\end_layout

\begin_layout Itemize
No environments.
\end_layout

\begin_layout Itemize
No continuations (yet).
\end_layout

\begin_layout Itemize
No hygienic macros (yet!).
\end_layout

\begin_layout Standard
Common Lisp
\end_layout

\begin_layout Itemize
Most of the standard library is missing.
\end_layout

\begin_layout Itemize
Functions and variables occupy the same namespace.
\end_layout

\begin_layout Itemize
No condition/restart system.
\end_layout

\begin_layout Subsection
Similarities With...
\end_layout

\begin_layout Standard
Scheme
\end_layout

\begin_layout Itemize
Use of punctuation with intent: ! indicates side-effects, ? indicates predicates
 etc.
\end_layout

\begin_layout Itemize
Properly tail-recursive.
\end_layout

\begin_layout Itemize
Small language core.
\end_layout

\begin_layout Itemize
Functional bias.
\end_layout

\begin_layout Standard
Common Lisp
\end_layout

\begin_layout Itemize
Macros.
\end_layout

\begin_layout Itemize
Package system.
\end_layout

\begin_layout Itemize
Keywords (albeit with different syntax).
\end_layout

\begin_layout Subsection
S-Expressions
\end_layout

\begin_layout LyX-Code
; comments (like this) are ignored
\end_layout

\begin_layout LyX-Code
1 2.0 3/1 4+0i ; numbers
\end_layout

\begin_layout LyX-Code
#
\backslash
h ; character
\end_layout

\begin_layout LyX-Code
\begin_inset Quotes eld
\end_inset

hello
\begin_inset Quotes erd
\end_inset

 ; string
\end_layout

\begin_layout LyX-Code
hello a + 2cool4u ; symbols
\end_layout

\begin_layout LyX-Code
(a b c) [d e f] ; lists
\end_layout

\begin_layout LyX-Code
() [] ; empty lists
\end_layout

\begin_layout LyX-Code
(1 .
 2) ; pair
\end_layout

\begin_layout LyX-Code
(1 2 .
 3) ; improper list
\end_layout

\begin_layout Subsection
Golisp Expressions
\end_layout

\begin_layout Subsection
Standard Forms
\end_layout

\begin_layout LyX-Code
(quote 
\emph on
datum
\emph default
)
\end_layout

\begin_layout LyX-Code
(if 
\emph on
test then else
\emph default
)
\end_layout

\begin_layout LyX-Code
(lambda 
\emph on
vars body
\emph default
 ...)
\end_layout

\begin_layout LyX-Code
(set! 
\emph on
var val
\emph default
)
\end_layout

\begin_layout LyX-Code
(
\emph on
f args 
\emph default
...)
\end_layout

\begin_layout Standard
The five standard forms essentially define the semantics of Golisp.
\end_layout

\begin_layout Description
quote withholds evaluation.
\end_layout

\begin_layout Description
if conditionally evaluates.
\end_layout

\begin_layout Description
lambda creates functions.
\end_layout

\begin_layout Description
set! modifies variables.
\end_layout

\begin_layout Description
call calls functions.
\end_layout

\begin_layout Subsection
Variables
\end_layout

\begin_layout Subsubsection
Variable Forms
\end_layout

\begin_layout LyX-Code
(bound 
\emph on
idx
\emph default
)
\end_layout

\begin_layout LyX-Code
(free 
\emph on
idx
\emph default
)
\end_layout

\begin_layout LyX-Code
(global 
\emph on
sym
\emph default
)
\end_layout

\begin_layout LyX-Code
(unbox 
\emph on
var
\emph default
)
\end_layout

\begin_layout Standard
These are included for informational purposes only.
 It is not possible to use these forms in Golisp code.
 Don't worry! They don't actually look like this, and you can define your
 own things with these names, if you want.
 They are included here to help understand the rest of it.
\end_layout

\begin_layout Standard
Golisp knows about three kinds of environment.
 There are 
\emph on
bound variables
\emph default
, those that have just been passed into a function; 
\emph on
free variables
\emph default
, those that were in scope when the function was created; and 
\emph on
global variables
\emph default
, those that are always in scope.
 This is transparent to the programmer: everything works as expected for
 a Lisper.
\end_layout

\begin_layout Standard
e.g.
\end_layout

\begin_layout LyX-Code
(define (adder x)
\end_layout

\begin_layout LyX-Code
  (lambda (y)
\end_layout

\begin_layout LyX-Code
    (set! x (+ x y)) ; + is global, x is free, y is bound
\end_layout

\begin_layout LyX-Code
    x))
\end_layout

\begin_layout Standard
This is something to know as an implementation detail, as it underlies the
 optimisation techniques in the compiler.
 Nevertheless, that there is, for instance, a single global environment,
 is instructive.
\end_layout

\begin_layout Subsection
Functions
\end_layout

\begin_layout Standard
The core implementation of Golisp, variable management aside, is concerned
 primarily with functions and their application.
 Functions are first-class values and obey lexical scoping rules.
 Functions are properly tail recursive.
 That is, if the last thing a function does is call another function, the
 callee takes the stack frame of the caller.
 This is implemented with a trampoline.
 It only works for functions defined in Golisp; primitives do not benefit
 from this.
\end_layout

\begin_layout Subsubsection
Lambda Expressions
\end_layout

\begin_layout LyX-Code
(lambda 
\emph on
vars body 
\emph default
...)
\end_layout

\begin_layout Subsubsection
Define Statements
\end_layout

\begin_layout LyX-Code
(define (
\emph on
name args 
\emph default
...) 
\emph on
body 
\emph default
...)
\end_layout

\begin_layout LyX-Code
=>
\end_layout

\begin_layout LyX-Code
(define 
\emph on
name 
\emph default
(lambda (
\emph on
args 
\emph default
...) 
\emph on
body 
\emph default
...))
\end_layout

\begin_layout Standard
This can be carried on indefinitely.
 So,
\end_layout

\begin_layout LyX-Code
(define (list .
 ls) ls)
\end_layout

\begin_layout LyX-Code
=> (define list (lambda ls ls))
\end_layout

\begin_layout LyX-Code
(define ((const x) .
 _) x)
\end_layout

\begin_layout LyX-Code
=> (define (const x) (lambda _ x))
\end_layout

\begin_layout LyX-Code
=> (define const (lambda (x) (lambda _ x)))
\end_layout

\begin_layout Subsubsection
Lambda Expansion
\end_layout

\begin_layout Standard
Lambda expansion adds annotations to lambda expressions, to ease their evaluatio
n.
\end_layout

\begin_layout LyX-Code
(lambda 
\emph on
vars body
\emph default
 ...)
\end_layout

\begin_layout LyX-Code
=>
\end_layout

\begin_layout LyX-Code
(lambda 
\emph on
closed boxed vars body
\emph default
 ...)
\end_layout

\begin_layout Standard
e.g.
\end_layout

\begin_layout LyX-Code
(lambda (a) 
\end_layout

\begin_layout LyX-Code
  (lambda (b) 
\end_layout

\begin_layout LyX-Code
    (+ a b)))
\end_layout

\begin_layout LyX-Code
=> (lambda () () (a) 
\end_layout

\begin_layout LyX-Code
     (lambda (a) () (b) 
\end_layout

\begin_layout LyX-Code
       (+ a b)))
\end_layout

\begin_layout LyX-Code
=> (lambda () () (a) 
\end_layout

\begin_layout LyX-Code
     (lambda ((bound 0)) () (b)
\end_layout

\begin_layout LyX-Code
       ((unbox (global +)) (free 0) (bound 0))))
\end_layout

\begin_layout LyX-Code
(define ((adder x) y) 
\end_layout

\begin_layout LyX-Code
  (set! x (+ x y)) x)
\end_layout

\begin_layout LyX-Code
=> (define (adder x) 
\end_layout

\begin_layout LyX-Code
     (lambda (y) 
\end_layout

\begin_layout LyX-Code
       (set! x (+ x y)) x))
\end_layout

\begin_layout LyX-Code
=> (define adder 
\end_layout

\begin_layout LyX-Code
     (lambda (x) 
\end_layout

\begin_layout LyX-Code
       (lambda (y) 
\end_layout

\begin_layout LyX-Code
         (set! x (+ x y)) x)))
\end_layout

\begin_layout LyX-Code
=> (define adder 
\end_layout

\begin_layout LyX-Code
     (lambda () (x) (x) 
\end_layout

\begin_layout LyX-Code
       (lambda (x) () (y) 
\end_layout

\begin_layout LyX-Code
         (set! x (+ x y)) x)))
\end_layout

\begin_layout LyX-Code
=> (define adder 
\end_layout

\begin_layout LyX-Code
     (lambda () (0) (x) 
\end_layout

\begin_layout LyX-Code
       (lambda ((bound 0)) () (y) 
\end_layout

\begin_layout LyX-Code
         (set! (free 0) ((unbox (global +)) (unbox (free 0)) 
\end_layout

\begin_layout LyX-Code
                                            (bound 0))) 
\end_layout

\begin_layout LyX-Code
         (unbox (free 0)))))
\end_layout

\begin_layout Subsection
Evaluation
\end_layout

\begin_layout Subsection
Macros
\end_layout

\begin_layout Section
Primitives
\end_layout

\begin_layout Standard
Primitives are Golisp functions that are implemented in Go.
 They have the following type signature.
\end_layout

\begin_layout LyX-Code
type Primitive func(args []Value) Value
\end_layout

\begin_layout Standard
They provide functionality that is either impossible or very costly to do
 in Golisp.
 This revolves around access to wider system resources and communication
 with them, but also includes things like number manipulation, manipulating
 collections, and so on.
\end_layout

\begin_layout Subsection
Maths Primitives
\end_layout

\begin_layout Standard
Manipulating numbers, and accessing important mathematical functions, are
 the order of the day.
\end_layout

\begin_layout Subsection
Character Primitives
\end_layout

\begin_layout Standard
These primitives primarily concern themselves with Unicode.
\end_layout

\begin_layout Subsection
String Primitives
\end_layout

\begin_layout Standard
Selecting from, concatenating, searching strings.
 All good fun.
 Like in Go, strings are UTF-8, characters are Unicode code points.
\end_layout

\begin_layout Standard
A good trick is to build a list of strings, then (apply string-append list-of-st
rings).
 This is equivalent to string builder type things.
\end_layout

\begin_layout LyX-Code
(string-ref 
\emph on
s idx
\emph default
)
\end_layout

\begin_layout LyX-Code
(string-length 
\emph on
s
\emph default
)
\end_layout

\begin_layout LyX-Code
(string-append 
\emph on
s
\emph default
 ...)
\end_layout

\begin_layout LyX-Code
(substring 
\emph on
s from to
\emph default
)
\end_layout

\begin_layout LyX-Code
(string-fold 
\emph on
f init s
\emph default
)
\end_layout

\begin_layout Subsection
List Primitives
\end_layout

\begin_layout Standard
Lists are important to any Lisp implementation.
 
\end_layout

\begin_layout LyX-Code
(cons 
\emph on
a b
\emph default
)
\end_layout

\begin_layout LyX-Code
(car 
\emph on
p
\emph default
)
\end_layout

\begin_layout LyX-Code
(cdr 
\emph on
p
\emph default
)
\end_layout

\begin_layout LyX-Code
(set-car! 
\emph on
p x
\emph default
)
\end_layout

\begin_layout LyX-Code
(set-cdr! 
\emph on
p x
\emph default
)
\end_layout

\begin_layout Subsection
Vector Primitives
\end_layout

\begin_layout Standard
Vectors are equivalent to Go's arrays or slices.
\end_layout

\begin_layout Subsection
Map Primitives
\end_layout

\begin_layout Subsection
Control Primitives
\end_layout

\begin_layout Subsection
System Primitives
\end_layout

\begin_layout Standard
These primitives are concerned with either control of the Golisp interpreter,
 or of the wider operating system.
\end_layout

\begin_layout Section
The Interpreter
\end_layout

\begin_layout Standard
The Golisp interpreter is a Go object.
 Most of the mechanisms for interacting with a Golisp system involve communicati
ng with this object.
\end_layout

\begin_layout Subsection
Interpreter API
\end_layout

\begin_layout Section
Errors
\end_layout

\begin_layout Standard
Go raised some consternation from some quarters when it was revealed because
 it lacked exceptions.
 It may surprise them that the author of this document is somewhat embarassed
 to reveal that Golisp currently handles errors in much the same way as
 exceptions.
 This is because a much more powerful notion, one that encompasses exceptions,
 breaks, continues and immediate returns, and whatever else the clever hacker
 can imagine, in Scheme.
\end_layout

\begin_layout Standard
Errors are objects that are treated specially by the runtime.
 All of the internals of the interpreter will ferry an error object up the
 call chain.
 Primitives must handle error objects explicitly.
 Failed(x) will return true if x is an error object.
 The obvious thing to do with error objects is to return them immediately;
 Golisp provides mechanisms for handling errors.
 This is your basic try-catch exception deal.
 Full continuations may appear at some point, until then, this special case
 is most pressing.
\end_layout

\begin_layout Standard
Golisp provides functions for emitting and receiving errors.
\end_layout

\begin_layout Subsection
Emission
\end_layout

\begin_layout LyX-Code
(signal-error 
\emph on
type
\emph default
 
\emph on
msg
\emph default
)
\end_layout

\begin_layout LyX-Code
(error 
\emph on
msg
\emph default
)
\end_layout

\begin_layout LyX-Code
(type-error 
\emph on
x
\emph default
)
\end_layout

\begin_layout LyX-Code
(argument-error 
\emph on
args
\emph default
)
\end_layout

\begin_layout Standard
Signal different kinds of error.
\end_layout

\begin_layout Subsection
Reception
\end_layout

\begin_layout LyX-Code
(split 
\emph on
thk hnd
\emph default
)
\end_layout

\begin_layout Standard
Call thk, and if it results in an error, call hnd with the properties of
 the error.
 If an error was raised, split evaluates to the result of hnd, otherwise
 it evaluates to the result of thk.
 An error may be signalled in hnd (at which point, presumably, another handler
 would be invoked).
 The 
\begin_inset Quotes eld
\end_inset

root
\begin_inset Quotes erd
\end_inset

 handler, as it were, prints the error's message, and then quits the program
 abnormally.
 The REPL installs a handler that simply prints the message and carries
 on.
 Fairly primitive, I know.
 I'm working on it.
\end_layout

\begin_layout LyX-Code
> (/ 1 0)
\end_layout

\begin_layout LyX-Code

\emph on
error: division by zero
\end_layout

\begin_layout LyX-Code
> (split (lambda () (/ 1 0)) (lambda (type msg) msg))
\end_layout

\begin_layout LyX-Code
\begin_inset Quotes eld
\end_inset

division by zero
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code
> (split (lambda () (/ 1 0)) (lambda (type msg) 
\begin_inset Quotes eld
\end_inset

wooo
\begin_inset Quotes erd
\end_inset

))
\end_layout

\begin_layout LyX-Code
\begin_inset Quotes eld
\end_inset

wooo
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code
> (split (lambda () (/ 1 0)) (lambda (type msg) (signal-error type msg)))
\end_layout

\begin_layout LyX-Code

\emph on
error: division by zero
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Section
Packages and Symbols
\end_layout

\begin_layout Standard
There is a single global environment in Golisp.
 This is partitioned into logical spaces by packages.
 There are two ways of looking at packages: bliss in (relative) ignorance,
 and cold hard reality.
 It is not possible to refer to packages directly, but an API for managing
 them is provided.
\end_layout

\begin_layout Subsection
Symbols
\end_layout

\begin_layout Standard
Symbols in Golisp roughly corespond to identifiers in other languages.
 They are first-class values because Golisp code is first-class, and identifiers
 are an important part of any piece of code.
 Symbols can also be used instead of enumerated types, although keywords
 are probably better for this.
 A symbol will evaluate to whatever variable it refers to.
 Quoting a symbol gives access to the symbol object upon evaluation.
\end_layout

\begin_layout LyX-Code
> (define a 1)
\end_layout

\begin_layout LyX-Code
> a
\end_layout

\begin_layout LyX-Code
1
\end_layout

\begin_layout LyX-Code
> 'a
\end_layout

\begin_layout LyX-Code
a
\end_layout

\begin_layout LyX-Code
> (symbol->string 'a)
\end_layout

\begin_layout LyX-Code
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code
> (eval 'a)
\end_layout

\begin_layout LyX-Code
1
\end_layout

\begin_layout Subsection
Symbol API
\end_layout

\begin_layout LyX-Code
(symbol->string s)
\end_layout

\begin_layout LyX-Code
(string->symbol s)
\end_layout

\begin_layout LyX-Code
(unqualified s)
\end_layout

\begin_layout Subsection
Package API
\end_layout

\begin_layout LyX-Code
(define-package 
\emph on
name
\emph default
)
\end_layout

\begin_layout LyX-Code
(in-package 
\emph on
name
\emph default
)
\end_layout

\begin_layout LyX-Code
(import 
\emph on
name
\emph default
 ...)
\end_layout

\begin_layout LyX-Code
(export 
\emph on
name
\emph default
 ...)
\end_layout

\begin_layout LyX-Code
(list-packages)
\end_layout

\begin_layout LyX-Code
(package-description 
\emph on
name
\emph default
)
\end_layout

\begin_layout LyX-Code
(set-package-description! 
\emph on
desc
\emph default
)
\end_layout

\begin_layout Subsection
Bliss in Ignorance
\end_layout

\begin_layout Standard
If you're not interested in how the package system works internally, and
 just want to use a package to program with or what have you, then this
 is all you need to know about packages.
 Essentially, packages are collections of definitions, some of which the
 package 
\begin_inset Quotes eld
\end_inset

exports
\begin_inset Quotes erd
\end_inset

.
 If one were to import from a package, then all of the package's exported
 definitions become accessible.
\end_layout

\begin_layout LyX-Code
> (define-package 
\begin_inset Quotes eld
\end_inset

example
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout LyX-Code
> (export 
\begin_inset Quotes eld
\end_inset

hello
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout LyX-Code
> (define (hello) (display 
\begin_inset Quotes eld
\end_inset

Hello, world!
\begin_inset Quotes erd
\end_inset

) (newline))
\end_layout

\begin_layout LyX-Code
> (in-package 
\begin_inset Quotes eld
\end_inset


\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout LyX-Code
> (import 
\begin_inset Quotes eld
\end_inset

example
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout LyX-Code
> (hello)
\end_layout

\begin_layout LyX-Code

\emph on
Hello, world!
\end_layout

\begin_layout Subsection
Cold Hard Reality
\end_layout

\begin_layout Standard
The package system is implemented internally through a symbol table and
 a package table.
 The magic happens at symbol creation.
 If the symbol name has a colon in it, then a symbol corresponding to the
 name is created.
 Otherwise, if the name is already defined for the current package, the
 appropriate symbol is returned.
 Otherwise, the current package's name followed by a colon is prepended
 to the name, and a corresponding symbol is returned.
 Every symbol has a value associated with it, that is used to implement
 global variables.
 So the cost for looking up global variables is all borne at read-time,
 and when it comes to it is just as quick as bound or free scope.
\end_layout

\begin_layout LyX-Code
> (define-package 
\begin_inset Quotes eld
\end_inset

example2
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout LyX-Code
> 'hello
\end_layout

\begin_layout LyX-Code
example2:hello
\end_layout

\begin_layout LyX-Code
> (export 
\begin_inset Quotes eld
\end_inset

hello
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout LyX-Code
> (in-package 
\begin_inset Quotes eld
\end_inset


\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout LyX-Code
> 'hello
\end_layout

\begin_layout LyX-Code
hello
\end_layout

\begin_layout LyX-Code
> (define-package 
\begin_inset Quotes eld
\end_inset

example3
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout LyX-Code
> (export 
\begin_inset Quotes eld
\end_inset

hello
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes eld
\end_inset

woo
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout LyX-Code
> (import 
\begin_inset Quotes eld
\end_inset

example2
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout LyX-Code
> (in-package 
\begin_inset Quotes eld
\end_inset


\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout LyX-Code
> (import 
\begin_inset Quotes eld
\end_inset

example3
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout LyX-Code
> 'hello
\end_layout

\begin_layout LyX-Code
example2:hello
\end_layout

\begin_layout LyX-Code
> 'woo
\end_layout

\begin_layout LyX-Code
example3:woo
\end_layout

\begin_layout Subsection
Included Packages
\end_layout

\begin_layout LyX-Code
prelude
\end_layout

\begin_layout LyX-Code

\end_layout

\end_body
\end_document
